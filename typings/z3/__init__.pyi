from typing import Any, Iterable, Tuple, overload

# === Core Expression Types ===

class BoolRef:
    ...

class ArithRef:
    # Arithmetic operators return ArithRef
    def __add__(self, other: "ArithRef") -> "ArithRef": ...
    def __radd__(self, other: "ArithRef") -> "ArithRef": ...
    def __sub__(self, other: "ArithRef") -> "ArithRef": ...
    def __rsub__(self, other: "ArithRef") -> "ArithRef": ...
    def __mul__(self, other: "ArithRef") -> "ArithRef": ...

    # Comparisons return BoolRef
    def __eq__(self, other: Any) -> BoolRef: ...
    def __ne__(self, other: Any) -> BoolRef: ...
    def __ge__(self, other: Any) -> BoolRef: ...
    def __gt__(self, other: Any) -> BoolRef: ...
    def __le__(self, other: Any) -> BoolRef: ...
    def __lt__(self, other: Any) -> BoolRef: ...

class IntNumRef(ArithRef):
    def as_long(self) -> int: ...


# === Or / And / Not ===

def Or(*args: BoolRef) -> BoolRef: ...
def And(*args: BoolRef) -> BoolRef: ...
def Not(arg: BoolRef) -> BoolRef: ...


# === Solver & Optimize ===

class OptimizeHandle:
    def value(self) -> IntNumRef: ...

class Solver:
    def add(self, *constraints: BoolRef) -> None: ...
    def check(self) -> Any: ...
    def model(self) -> Any: ...

class Optimize:
    def add(self, *constraints: BoolRef) -> None: ...
    def check(self) -> Any: ...
    def minimize(self, expr: ArithRef) -> OptimizeHandle: ...
    def maximize(self, expr: ArithRef) -> OptimizeHandle: ...
    def model(self) -> Any: ...


# === Constructors ===

def Int(name: str) -> ArithRef: ...

def Ints(*names: str) -> Tuple[ArithRef, ...]: ...

def Sum(*args: ArithRef) -> ArithRef: ...

